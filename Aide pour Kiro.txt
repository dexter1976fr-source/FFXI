================================================================================
PACK COMPLET DE CORRECTIFS POUR LE BARD AUTO-CAST
================================================================================

Ce fichier contient 3 sections :
1. AutoCast_BRD.lua (le fichier principal corrig√©)
2. AltControl.lua (le fichier de contr√¥le corrig√©)
3. Instructions pour Kiro

Copiez chaque section dans un fichier s√©par√© sur votre PC.

================================================================================
FICHIER 1 : AutoCast_BRD.lua
================================================================================

----------------------------------------------------------
-- AUTO CAST BRD - VERSION CORRIG√âE (SMART FOLLOW)
-- Int√®gre la gestion intelligente du mouvement pour √©viter les interruptions
----------------------------------------------------------

local brd = {
    -- Configuration
    config = {
        healerTarget = nil,
        meleeTarget = nil,
        mageSongs = {},
        meleeSongs = {},
    },
    
    -- √âtat
    active = false,
    song_queue = {},
    last_queue_process = 0,
    
    -- Gestion Mouvement
    STOP_DISTANCE = 3.0,    -- Distance d'arr√™t (yalms)
    CAST_RANGE = 18.0,      -- Port√©e max des sorts
    state = {
        is_moving = false,
        target_locked = nil,
        last_stop_time = 0
    }
}

----------------------------------------------------------
-- CHARGEMENT DE LA CONFIG
----------------------------------------------------------
function brd.load_config()
    local config_path = windower.addon_path..'data/autocast_config.json'
    local file = io.open(config_path, 'r')
    
    if not file then
        print('[BRD] ‚ö†Ô∏è Config file not found')
        return false
    end
    
    local content = file:read('*all')
    file:close()
    
    -- Parser le JSON manuellement
    local healer = content:match('"healerTarget"%s*:%s*"([^"]+)"')
    local melee = content:match('"meleeTarget"%s*:%s*"([^"]+)"')
    
    if healer then brd.config.healerTarget = healer end
    if melee then brd.config.meleeTarget = melee end
    
    -- Parser les songs
    local mage_songs_str = content:match('"mageSongs"%s*:%s*%[([^%]]+)%]')
    if mage_songs_str then
        brd.config.mageSongs = {}
        for song in mage_songs_str:gmatch('"([^"]+)"') do
            table.insert(brd.config.mageSongs, song)
        end
    end
    
    local melee_songs_str = content:match('"meleeSongs"%s*:%s*%[([^%]]+)%]')
    if melee_songs_str then
        brd.config.meleeSongs = {}
        for song in melee_songs_str:gmatch('"([^"]+)"') do
            table.insert(brd.config.meleeSongs, song)
        end
    end
    
    print('[BRD] ‚úÖ Config loaded with Smart Follow logic')
    return true
end

----------------------------------------------------------
-- QUEUE DE SONGS
----------------------------------------------------------
function brd.queue_song(song_name, target)
    table.insert(brd.song_queue, {
        song = song_name,
        target = target or '<me>'
    })
    print('[BRD] üìã Queued: '..song_name..' on '..(target or '<me>'))
end

----------------------------------------------------------
-- LOGIQUE SMART FOLLOW (LE C≈íUR DU CORRECTIF)
----------------------------------------------------------
function brd.handle_smart_movement_and_cast(target_name, song_to_cast)
    local player = windower.ffxi.get_player()
    local target = windower.ffxi.get_mob_by_name(target_name)
    
    if not player or not target then return "error" end
    
    local distance = target.distance:sqrt()
    
    -- 1. PROTECTION CAST
    if player.status == 4 then -- Casting
        if distance > brd.CAST_RANGE then
            windower.send_command('input /scmd interrupt')
            return "interrupted"
        end
        return "casting"
    end

    -- 2. PHASE APPROCHE
    if distance > brd.STOP_DISTANCE then
        windower.ffxi.run(target.x - player.x, target.y - player.y)
        brd.state.is_moving = true
        return "moving"
    end

    -- 3. PHASE ARR√äT & STABILISATION
    if brd.state.is_moving then
        windower.ffxi.run(false) -- STOP NET
        brd.state.is_moving = false
        brd.state.last_stop_time = os.clock()
        return "stabilizing"
    end

    -- D√©lai de s√©curit√© apr√®s l'arr√™t (0.3s)
    if (os.clock() - brd.state.last_stop_time) < 0.3 then
        return "waiting_stop"
    end

    -- 4. PHASE CAST
    -- On est proche et arr√™t√© : ON CASTE
    windower.send_command('input /ma "'..song_to_cast..'" '..target_name)
    return "cast_started"
end

function brd.process_queue()
    if #brd.song_queue == 0 then return end
    
    local next_entry = brd.song_queue[1]
    local song = next_entry.song
    local target = next_entry.target
    
    -- Si la cible est nous-m√™me, pas de mouvement
    if target == '<me>' or target == windower.ffxi.get_player().name then
        local player = windower.ffxi.get_player()
        if player.status == 4 then return end -- Occup√©
        
        windower.send_command('input /ma "'..song..'" <me>')
        table.remove(brd.song_queue, 1)
        return
    end

    -- Logique Smart Follow pour les autres cibles
    local status = brd.handle_smart_movement_and_cast(target, song)
    
    if status == "cast_started" then
        print('[BRD] üéµ Cast lanc√© : '..song..' (Smart Distance Check OK)')
        table.remove(brd.song_queue, 1)
    elseif status == "moving" then
        -- On court, on attend le prochain tick
    elseif status == "stabilizing" then
        -- On freine, on attend le prochain tick
    end
end

----------------------------------------------------------
-- D√âMARRAGE / STOP / UPDATE
----------------------------------------------------------
function brd.start()
    print('[BRD] üéµ Starting AutoCast (Smart Follow Edition)...')
    if not brd.load_config() then return false end
    brd.active = true
    brd.song_queue = {}
    return true
end

function brd.stop()
    brd.active = false
    windower.ffxi.run(false) -- Arr√™t d'urgence
    brd.song_queue = {}
    print('[BRD] üõë AutoCast stopped')
end

function brd.update(config, player)
    if not brd.active then return end
    if not player then return end
    
    brd.process_queue()
end

function brd.init()
    print('[BRD] Module initialized')
end

function brd.cleanup()
    brd.stop()
end

function brd.on_action(action, player)
end

return brd

================================================================================
FICHIER 2 : AltControl.lua
================================================================================

----------------------------------------------------------
-- ALT DATA SYNC - VERSION PATCH√âE
-- Assure que AutoCast (BRD) est appel√© dans la boucle principale
----------------------------------------------------------

_addon = _addon or {}
_addon.name = 'AltControl'
_addon.author = 'FFXI ALT Control Team'
_addon.version = '1.2.0'
_addon.commands = {'altcontrol', 'ac'}

local socket = require('socket')
local host = "127.0.0.1"
local base_port = 5007

local autocast = nil

function load_autocast()
    if not autocast then
        local success, module = pcall(require, 'AutoCast')
        if success then
            autocast = module
            print('[AltControl] ‚úÖ AutoCast module loaded')
            return true
        else
            print('[AltControl] ‚ùå Failed to load AutoCast:', module)
            return false
        end
    end
    return true
end

function start_autocast(config_json)
    if load_autocast() then
        return autocast.start(config_json)
    end
    return false
end

function stop_autocast()
    if autocast then
        autocast.stop()
    end
end

----------------------------------------------------------
-- üîπ BOUCLE PRINCIPALE (CRITIQUE POUR LE SMART FOLLOW)
----------------------------------------------------------
-- C'est cette boucle qui appelle constamment brd.update()
-- qui g√®re le mouvement intelligent

windower.register_event('prerender', function()
    if autocast and autocast.is_active and autocast.is_active() then
        autocast.update()
    end
end)

----------------------------------------------------------
-- üîπ CAPTURE DES ACTIONS (pour d√©tecter fin de cast)
----------------------------------------------------------
windower.register_event('action', function(action)
    if autocast and autocast.on_action then
        autocast.on_action(action)
    end
end)

----------------------------------------------------------
-- üîπ COMMANDES
----------------------------------------------------------
windower.register_event('addon command', function(command, ...)
    command = command and command:lower() or nil
    
    if command == 'start' then
        if start_autocast() then
            print('[AltControl] ‚úÖ AutoCast started')
        else
            print('[AltControl] ‚ùå Failed to start')
        end
        
    elseif command == 'stop' then
        stop_autocast()
        print('[AltControl] ‚úÖ AutoCast stopped')
        
    elseif command == 'status' then
        if autocast and autocast.is_active() then
            print('[AltControl] AutoCast is ACTIVE')
        else
            print('[AltControl] AutoCast is INACTIVE')
        end
        
    elseif command == 'queue_song' then
        local args = {...}
        if #args >= 1 then
            local song = args[1]
            local target = args[2] or '<me>'
            
            if autocast and autocast.is_active() then
                local player = windower.ffxi.get_player()
                if player and player.main_job == 'BRD' then
                    local job_module = autocast.job_modules and autocast.job_modules['BRD']
                    if job_module and job_module.queue_song then
                        job_module.queue_song(song, target)
                        print('[AltControl] ‚úÖ Song queued: '..song)
                    end
                end
            end
        end
    end
end)

----------------------------------------------------------
-- üîπ CLEANUP
----------------------------------------------------------
windower.register_event('unload', function()
    if autocast then
        stop_autocast()
    end
end)

print('[AltControl] Loaded (Smart Follow Edition)')

================================================================================
FICHIER 3 : INSTRUCTIONS POUR KIRO
================================================================================

# PACK DE CORRECTIFS POUR LE BARD AUTO-CAST

## Probl√®me R√©solu
Le Barde utilise /follow qui colle √† la cible. D√®s que la cible bouge de 1 pixel, 
le cast est annul√© ("You must wait longer to perform that action").

## Solution : Smart Follow
Au lieu de suivre b√™tement, le Barde va maintenant :
1. Courir vers la cible jusqu'√† √™tre √† 3 yalms
2. S'arr√™ter compl√®tement (run(false))
3. Attendre 0.3 secondes que le serveur FFXI valide l'arr√™t
4. Caster le sort (sans bouger m√™me si la cible bouge un peu)

## Fichiers √† Remplacer

### 1. AutoCast_BRD.lua
Emplacement : Windower4/addons/AltControl/AutoCast_BRD.lua
Action : Remplacer par le FICHIER 1 ci-dessus

### 2. AltControl.lua
Emplacement : Windower4/addons/AltControl/AltControl.lua
Action : Remplacer par le FICHIER 2 ci-dessus

### 3. Python (Aucune modification requise)
Le serveur Python n'a pas besoin d'√™tre modifi√©.

## Test Rapide
Apr√®s avoir remplac√© les fichiers :

//ac start
//ac queue_song "Victory March" "Valain"

Vous devriez voir :
[BRD] üìã Queued: Victory March on Valain
[BRD] üéµ Cast lanc√© : Victory March (Smart Distance Check OK)

Si Valain bouge pendant le cast, le cast ne sera PAS annul√© 
(tant qu'il reste √† moins de 18 yalms).

================================================================================
FIN DU PACK
================================================================================
