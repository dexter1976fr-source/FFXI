================================================================================
KIRO - VOICI LE CODE FINAL POUR AutoCast_BRD.lua
================================================================================
INSTRUCTIONS :
1. Sauvegarde ton AutoCast_BRD.lua actuel (backup)
2. Remplace tout le contenu par le code ci-dessous
3. Recharge l'addon : //lua unload AltControl puis //lua load AltControl
4. Test : //ac start puis //ac queue_song "Victory March" "Valain"
LE PROBLEME QUI ETAIT L√Ä :
- Tu utilisais /follow qui colle √† la cible
- Quand la cible bouge, le Bard bouge aussi
- Le serveur voit le mouvement et annule le cast
- D'o√π : "You must wait longer to perform that action"
LA SOLUTION DANS CE CODE :
- Pause le /follow AVANT de caster (ligne ~165)
- S'arr√™te compl√®tement
- Caste sans bouger
- Relance le follow apr√®s 4 secondes (ligne ~173)
================================================================================
CODE : AutoCast_BRD.lua (COPIE TOUT CE QUI SUIT)
================================================================================
----------------------------------------------------------
-- AUTO CAST BRD - VERSION CORRIG√âE (Compatible Windower)
-- Gestion par le serveur Python avec Smart Distance
----------------------------------------------------------
local brd = {
    -- Configuration
    config = {
        healerTarget = nil,
        meleeTarget = nil,
        mageSongs = {},
        meleeSongs = {},
    },
    
    -- √âtat
    active = false,
    follow_target = nil,
    song_queue = {},
    last_queue_process = 0,
    
    -- Smart Follow
    is_following = false,
    follow_paused = false,
}
----------------------------------------------------------
-- CHARGEMENT DE LA CONFIG
----------------------------------------------------------
function brd.load_config()
    local config_path = windower.addon_path..'data/autocast_config.json'
    local file = io.open(config_path, 'r')
    
    if not file then
        print('[BRD] ‚ö†Ô∏è Config file not found')
        return false
    end
    
    local content = file:read('*all')
    file:close()
    
    -- Parser le JSON manuellement (simple)
    local healer = content:match('"healerTarget"%s*:%s*"([^"]+)"')
    local melee = content:match('"meleeTarget"%s*:%s*"([^"]+)"')
    
    if healer then brd.config.healerTarget = healer end
    if melee then brd.config.meleeTarget = melee end
    
    -- Parser les songs
    local mage_songs_str = content:match('"mageSongs"%s*:%s*%[([^%]]+)%]')
    if mage_songs_str then
        brd.config.mageSongs = {}
        for song in mage_songs_str:gmatch('"([^"]+)"') do
            table.insert(brd.config.mageSongs, song)
        end
    end
    
    local melee_songs_str = content:match('"meleeSongs"%s*:%s*%[([^%]]+)%]')
    if melee_songs_str then
        brd.config.meleeSongs = {}
        for song in melee_songs_str:gmatch('"([^"]+)"') do
            table.insert(brd.config.meleeSongs, song)
        end
    end
    
    print('[BRD] ‚úÖ Config loaded (Smart Follow)')
    return true
end
----------------------------------------------------------
-- FOLLOW INTELLIGENT (LE FIX CRITIQUE)
----------------------------------------------------------
function brd.follow(target_name)
    if not target_name then return end
    
    brd.follow_target = target_name
    brd.is_following = true
    brd.follow_paused = false
    
    windower.send_command('input /follow '..target_name)
    print('[BRD] üéØ Following: '..target_name)
end
function brd.pause_follow()
    if brd.is_following and not brd.follow_paused then
        windower.send_command('input /follow <me>')  -- Annule le follow
        windower.ffxi.run(false)  -- Arr√™te le mouvement
        brd.follow_paused = true
    end
end
function brd.resume_follow()
    if brd.is_following and brd.follow_paused and brd.follow_target then
        windower.send_command('input /follow '..brd.follow_target)
        brd.follow_paused = false
    end
end
function brd.stop_follow()
    brd.follow_target = nil
    brd.is_following = false
    brd.follow_paused = false
    windower.send_command('input /follow <me>')
    windower.ffxi.run(false)
    print('[BRD] üõë Stopped following')
end
----------------------------------------------------------
-- QUEUE DE SONGS
----------------------------------------------------------
function brd.queue_song(song_name, target)
    table.insert(brd.song_queue, {
        song = song_name,
        target = target or '<me>'
    })
    print('[BRD] üìã Queued: '..song_name..' on '..(target or '<me>'))
end
----------------------------------------------------------
-- PROCESS QUEUE (AVEC GESTION DISTANCE) - C'EST ICI QUE LE FIX OP√àRE
----------------------------------------------------------
function brd.process_queue()
    if #brd.song_queue == 0 then return end
    
    local player = windower.ffxi.get_player()
    if not player then return end
    
    -- Ne pas caster si d√©j√† en train de caster
    if player.status == 4 then return end
    
    -- V√©rifier cooldown
    local now = os.clock()
    if now - brd.last_queue_process < 0.5 then return end
    
    local next_song = brd.song_queue[1]
    local target_name = next_song.target
    
    -- Si la cible est <me> ou notre nom, pas de check de distance
    if target_name == '<me>' or target_name == player.name then
        if player.status == 0 or player.status == 1 then
            table.remove(brd.song_queue, 1)
            windower.send_command('input /ma "'..next_song.song..'" <me>')
            brd.last_queue_process = now
            print('[BRD] üéµ Casting: '..next_song.song..' on self')
        end
        return
    end
    
    -- Pour les autres cibles : v√©rifier la distance
    local target_mob = windower.ffxi.get_mob_by_name(target_name)
    
    if not target_mob then
        print('[BRD] ‚ö†Ô∏è Target not found: '..target_name)
        return
    end
    
    local distance = math.sqrt(target_mob.distance)
    
    -- Si trop loin (> 20 yalms = hors de port√©e), on attend
    if distance > 20 then
        print('[BRD] ‚è≥ Waiting... Target too far ('..string.format("%.1f", distance)..'y)')
        return
    end
    
    -- Si proche (< 20y) et pas en mouvement : PAUSE FOLLOW + CAST
    if player.status == 0 or player.status == 1 then
        -- *** ARR√äTER LE FOLLOW AVANT DE CASTER (C'EST LE FIX !!) ***
        brd.pause_follow()
        
        -- Petit d√©lai apr√®s pause (0.5s d√©j√† v√©rifi√© plus haut)
        table.remove(brd.song_queue, 1)
        windower.send_command('input /ma "'..next_song.song..'" '..target_name)
        brd.last_queue_process = now
        print('[BRD] üéµ Casting: '..next_song.song..' ('..string.format("%.1f", distance)..'y)')
        
        -- Reprendre le follow apr√®s 4 secondes (temps du cast)
        coroutine.schedule(function()
            brd.resume_follow()
        end, 4)
    end
end
----------------------------------------------------------
-- D√âMARRAGE
----------------------------------------------------------
function brd.start()
    print('[BRD] üéµ Starting AutoCast (Smart Follow)...')
    
    if not brd.load_config() then
        print('[BRD] ‚ùå Failed to load config')
        return false
    end
    
    brd.active = true
    brd.song_queue = {}
    
    -- Follow le healer par d√©faut
    if brd.config.healerTarget then
        brd.follow(brd.config.healerTarget)
    end
    
    print('[BRD] ‚úÖ AutoCast started')
    return true
end
function brd.stop()
    brd.active = false
    brd.stop_follow()
    brd.song_queue = {}
    print('[BRD] üõë AutoCast stopped')
end
----------------------------------------------------------
-- UPDATE
----------------------------------------------------------
function brd.update(config, player)
    if not brd.active then return end
    if not player then return end
    
    brd.process_queue()
end
----------------------------------------------------------
-- INIT / CLEANUP
----------------------------------------------------------
function brd.init()
    print('[BRD] Module initialized')
end
function brd.cleanup()
    brd.stop()
end
function brd.on_action(action, player)
end
return brd
================================================================================
FIN DU CODE
================================================================================
NE MODIFIE PAS CE CODE.
Utilise-le exactement tel quel.
SI TU AS UNE ERREUR SUR "coroutine.schedule" :
Si Windower dit "attempt to call field 'schedule' (a nil value)"
Remplace les lignes :
        coroutine.schedule(function()
            brd.resume_follow()
        end, 4)
Par :
        -- Pas de timer, le Python devra relancer le follow
Et alors le Python devra envoyer une commande pour relancer le follow apr√®s 4s.
================================================================================
C'EST TOUT.
Copie ce code, remplace AutoCast_BRD.lua, reload, et teste.
================================================================================